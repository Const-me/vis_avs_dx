<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cpp" #>
<#@ assembly name="System.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.ComponentModel" #>
// This file is automatically generated.
#include "stdafx.h"
#include "shadersCode.h"
#include "../Utils/decompressor.h"

namespace
{
	const uint8_t* dxbcBufferPointer();
	const char* hlslBufferPointer();

	struct Source
	{
		const char* const name;
		const uint32_t offset, length;
		constexpr Source( const char* n, uint32_t off, uint32_t l ) :
			name( n ), offset( off ), length( l ) { }
	};

	class IncludesMap
	{
		void initialize( std::initializer_list<Source> entries )
		{
			const char* ptr = hlslBufferPointer();
			for( auto e : entries )
				map[ e.name ] = CStringA{ ptr + e.offset, (int)e.length };
		}

	public:
		CAtlMap<CStringA, CStringA> map;

		IncludesMap( std::initializer_list<Source> entries )
		{
			initialize( entries );
			map.Rehash();
		}

		IncludesMap( const CAtlMap<CStringA, CStringA>& parent, std::initializer_list<Source> entries )
		{
			initialize( entries );
			for( POSITION pos = parent.GetStartPosition(); nullptr != pos; )
			{
				auto p = parent.GetNext( pos );
				if( nullptr == map.Lookup( p->m_key ) )
					map.SetAt( p->m_key, p->m_value );
			}
			map.Rehash();
		}
	};
}

namespace Hlsl
{<#= writeNamespaces( generateNamespaces ) #>
	namespace StaticShaders
	{
<#= makeStaticShaders() #>
	}
}

namespace
{
	const char* hlslBufferPointer()
	{
<#= compressHlsl.compress() 
#>		return (const char*)buffer.data();
	}
	const uint8_t* dxbcBufferPointer()
	{
<#= compressDxbc.compress()
#>		return buffer.data();
	}
}<#@ include file="IncludeShaders.t4"#>
<#@ include file="../compress.t4"#><#+

void makeShader( CppBuilder sb, string path )
{
	BytesRange src = compressDxbc.add( path );
	byte[] orig = File.ReadAllBytes( path );
	byte[] compressed = compressBuffer( orig );
	sb.line( "		ByteRange {0}()", Path.GetFileNameWithoutExtension( path ) );
	sb.line( "		{" );
	sb.line( "			return ByteRange{{ dxbcBufferPointer() + {0}, {1} }};", src.offset, src.length );
	sb.line( "		};" );
	Console.WriteLine( "Included a static shader from {0}", Path.GetFileName( path ) );
}

string makeStaticShaders()
{
	CppBuilder sb = new CppBuilder();
	foreach( var path in staticShaders )
		makeShader( sb, path );
	return sb.ToString().TrimEnd();
}

static void writeIncludes( CppBuilder sb, NamespaceData ns, int lvl )
{
	sb.setTabs( lvl );
	sb.tl( "const CAtlMap<CStringA, CStringA>& includes()" );
	sb.tl( "{" );
	sb.incTabs();

	var ranges = ns.headers
		.Select( hlsl =>
		{
			var range = compressHlsl.addFile( hlsl );
			string inc = Path.GetFileName( hlsl ).ToLowerInvariant();
			return string.Format( @"Source{{ ""{0}"", {1}, {2} }}", inc, range.offset, range.length );
		} );

	// Include parent scope includes, if any
	NamespaceData parent = ns.parents().FirstOrDefault( n => n.anyInclude );
	if( null == parent )
		sb.tl( "static const IncludesMap result{{ {{ {0} }} }};", string.Join( ", ", ranges ) );
	else
		sb.tl( "static const IncludesMap result{{ ::{0}::includes(), {{ {1} }} }};", parent.fullName, string.Join( ", ", ranges ) );
	sb.tl( "return result.map;" );
	sb.decTabs();
	sb.tl( "};" );

	Console.WriteLine( "Generated {0} in {1}", pluralString( ns.headers.Length, "include" ), ns.fullName );
}

static int firstIndex( string[] lines, Func<string,bool> test, int start = 0 )
{
	for( int i = start; i < lines.Length; i++ )
		if( test( lines[ i ] ) )
			return i;
	return -1;
}

void writeTemplate( CppBuilder sb, int lvl, string sourcePath )
{
	var range = compressHlsl.addFile( sourcePath );

	sb.setTabs( lvl );
	sb.tl( "const ShaderTemplate* {0}::shaderTemplate()", Path.GetFileNameWithoutExtension( sourcePath ) );
	sb.tl( "{" );
	sb.incTabs();
	sb.tl( "static const ShaderTemplate result{{ \"{0}\", {1} }};", Path.GetFileName( sourcePath ), range.stringCtor() );
	sb.tl( "return &result;" );
	sb.decTabs();
	sb.tl( "};" );

	Console.WriteLine( "Included a shader template from " + relativePath( sourceDir, sourcePath ) );
}

const string globalBegin = "<global>";
const string globalEnd = "</global>";
const string entryPoint = "void main()";
const string isBeatMacro = "IS_BEAT";

static void writeStateTemplate( CppBuilder sb, int lvl, string sourcePath )
{
	string content = File.ReadAllText( sourcePath, Encoding.ASCII );

	// Find global blocks
	HashSet<string> globals = new HashSet<string>();
	int iStart = 0;
	while( true )
	{
		iStart = content.IndexOf( globalBegin, iStart );
		if( iStart < 0 ) break;
		iStart += globalBegin.Length;

		int iEnd = content.IndexOf( globalEnd, iStart );
		if( iEnd < 0 )
			throw new ArgumentException( "<globals> tag wasn't closed in " + sourcePath );
		int iNewStart = iEnd + globalEnd.Length;
		for( iEnd--; content[ iEnd ] != '\n'; iEnd-- );

		string g = content.Substring( iStart, iEnd - iStart ).Trim();
		globals.Add( g );
	}

	// Find main
	iStart = content.IndexOf( entryPoint );
	if( iStart < 0 )
		throw new ArgumentException( "\"void main()\" wasn't found in" + sourcePath );
	iStart += entryPoint.Length;
	content = content.Substring( iStart ).Trim();

	// Compress and write the data
	sb.setTabs( lvl );
	sb.tl( "const StateShaderTemplate* {0}::shaderTemplate()", Path.GetFileNameWithoutExtension( sourcePath ) );
	sb.tl( "{" );
	sb.incTabs();

	string[] rGlobals = globals
		.Select( s => compressHlsl.addFragment( s ).stringCtor() )
		.ToArray();

	sb.tl( "static const vector<CStringA> globals{{ {0} }};", string.Join( ", ", rGlobals ) );

	var rMain = compressHlsl.addFragment( content );

	bool hasBeat = content.Contains( isBeatMacro ) || globals.Any( s => s.Contains( isBeatMacro ) );

	sb.tl( "static const StateShaderTemplate result{{ \"{0}\", {1}, {2}, globals }};",
		Path.GetFileName( sourcePath ),
		rMain.stringCtor(),
		hasBeat ? "true" : "false" );
	sb.tl( "return &result;" );

	sb.decTabs();
	sb.tl( "};" );
}

void generateNamespaces( CppBuilder sb, NamespaceData ns, int lvl )
{
	if( ns.anyInclude )
		writeIncludes( sb, ns, lvl );

	if( ns.sources.Length > 0 )
	{
		foreach( string s in ns.sources )
		{
			if( isStateTemplate( s ) )
				writeStateTemplate( sb, lvl, s );
			else
				writeTemplate( sb, lvl, s );
		}
	}
}

class BytesRange
{
	public readonly int offset;
	public readonly int length;

	public BytesRange( int off, int l )
	{
		offset = off;
		length = l;
	}

	public string stringCtor()
	{
		return $"CStringA{{ hlslBufferPointer() + { offset }, { length } }}";
	}
}

class Compressor
{
	readonly List<byte> origBuffer = new List<byte>();

	protected BytesRange addBytes( byte[] data, bool nullTerminate )
	{
		var res = new BytesRange( origBuffer.Count, data.Length );
		origBuffer.AddRange( data );
		if( nullTerminate )
			origBuffer.Add( 0 );
		return res;
	}

	public string compress()
	{
		CppBuilder sb = new CppBuilder();
		sb.setTabs( 1 );
		sb.tl( "const uint8_t src[] = " );
		byte[] orig = origBuffer.ToArray();
		byte[] compressed = compressBuffer( orig );
		printBytes( sb, compressed );
		sb.tl( "static const vector<uint8_t> buffer = decompressBytes( src, {0}, {1} );	// {2:P1}", compressed.Length, orig.Length, (double)compressed.Length / orig.Length );
		return sb.ToString();
	}
}

class HlslCompressor: Compressor
{
	static string stripComment( string line )
	{
		int ind = line.IndexOf( "//" );
		if( ind < 0 )
			return line;
		return line.Substring( 0, ind ).TrimEnd();
	}

	public BytesRange addFile( string path )
	{
		// Remove comments and empty lines
		string[] lines = File.ReadAllLines(path)
			.Select( stripComment )
			.Where( l => !string.IsNullOrWhiteSpace( l ) )
			.ToArray();

		// Cleanup unused "#ifndef AVS_SHADER" portion of the HLSL, if any
		int indAvxShaderIfdef = firstIndex( lines, s => s == "#ifndef AVS_SHADER" );

		if( indAvxShaderIfdef >= 0 )
		{
			int indEndif = firstIndex( lines, s => s.StartsWith( "#endif" ), indAvxShaderIfdef );
			if( indEndif < 0 ) throw new ArgumentException( "Unmatched `#ifndef AVS_SHADER` in " + path );

			List<string> newLines = new List<string>();
			newLines.AddRange( lines.Take( indAvxShaderIfdef ) );
			newLines.AddRange( lines.Skip( indEndif + 1 ) );
			lines = newLines.ToArray();
			// Console.WriteLine( string.Join( "\r\n", lines ) );
		}

		byte[] data = Encoding.ASCII.GetBytes( string.Join( "\r\n", lines ) );
		return addBytes( data, true );
	}

	public BytesRange addFragment( string content )
	{
		byte[] data = Encoding.ASCII.GetBytes( content );
		return addBytes( data, true );
	}
}

class DxbcCompressor: Compressor
{
	public BytesRange add( string path )
	{
		byte[] data = File.ReadAllBytes( path );
		return addBytes( data, false );
	}
}

static readonly HlslCompressor compressHlsl = new HlslCompressor();
static readonly DxbcCompressor compressDxbc = new DxbcCompressor();

#>