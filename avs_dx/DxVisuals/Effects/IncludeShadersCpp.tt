<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cpp" #>
<#@ assembly name="System.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.ComponentModel" #>
// This file is automatically generated.
#include "stdafx.h"
#include "shadersCode.h"
#include "../Utils/decompressor.h"
#include <tuple>

namespace
{
	template<size_t size>
	class IncludesMap
	{
		void decompress( std::array<const char*, size> names, std::array<std::tuple<const uint8_t*, int, int>, size> compressedValues )
		{
			for( size_t i = 0; i < size; i++ )
				map[ names[ i ] ] = std::apply( decompressString, compressedValues[ i ] );
		}
	public:
		CAtlMap<CStringA, CStringA> map;

		IncludesMap( std::array<const char*, size> names, std::array<std::tuple<const uint8_t*, int, int>, size> compressedValues )
		{
			decompress( names, compressedValues );
			map.Rehash();
		}

		IncludesMap( const CAtlMap<CStringA, CStringA>& parent, std::array<const char*, size> names, std::array<std::tuple<const uint8_t*, int, int>, size> compressedValues )
		{
			decompress( names, compressedValues );
			for( POSITION pos = parent.GetStartPosition(); nullptr != pos; )
			{
				auto p = parent.GetNext( pos );
				if( nullptr == map.Lookup( p->m_key ) )
					map.SetAt( p->m_key, p->m_value );
			}
			map.Rehash();
		}
	};
}

namespace Hlsl
{<#= writeNamespaces( generateNamespaces ) #>
	namespace StaticShaders
	{
<#= makeStaticShaders() #>
	}
}<#@ include file="IncludeShaders.t4"#>
<#@ include file="../compress.t4"#><#+

void makeShader( CppBuilder sb, string path )
{
	byte[] orig = File.ReadAllBytes( path );
	byte[] compressed = compressBuffer( orig );
	sb.tabs( 2 );
	sb.line( "std::vector<uint8_t> {0}()", Path.GetFileNameWithoutExtension( path ) );
	sb.line( "		{" );
	sb.line( "			const uint8_t src[] =", compressed.Length );
	printBytes( sb, compressed );
	sb.line( "			std::vector<uint8_t> result = decompressBytes( src, {0}, {1} );", compressed.Length, orig.Length );
	sb.line( "			return std::move( result );" );
	sb.line( "		};" );
	Console.WriteLine( "Included a static shader from {0}", Path.GetFileName( path ) );
}

string makeStaticShaders()
{
	CppBuilder sb = new CppBuilder();
	foreach( var path in staticShaders )
	{
		makeShader( sb, path );
		sb.line();
	}
	return sb.ToString().Trim();
}

static void writeIncludes( CppBuilder sb, NamespaceData ns, int lvl )
{
	sb.line( lvl );
	sb.print( "const CAtlMap<CStringA, CStringA>& includes()" );
	sb.line( lvl );
	sb.line( "{" );
	int[] origSize = new int[ ns.headers.Length ];
	int[] cmpSize = new int[ ns.headers.Length ];
	for( int i = 0; i < ns.headers.Length; i++ )
	{
		string hlsl = ns.headers[ i ];
		byte[] orig = File.ReadAllBytes( hlsl );
		byte[] compressed = compressBuffer( orig );

		sb.tabs( lvl + 1 );
		sb.line( "const uint8_t {0}[] =", Path.GetFileNameWithoutExtension( hlsl ) );
		printBytes( sb, compressed );
		origSize[ i ] = orig.Length;
		cmpSize[ i ] = compressed.Length;
	}

	sb.line( lvl + 1 );
	sb.print( "const std::array<std::tuple<const uint8_t*, int, int>, {0}> tuples = ", ns.headers.Length );
	sb.line( lvl + 2 );
	sb.print( "{ " );
	for( int i = 0; i < ns.headers.Length; i++ )
	{
		sb.print( "std::make_tuple( &{0}[0], {1}, {2} )", Path.GetFileNameWithoutExtension( ns.headers[ i ] ), cmpSize[ i ], origSize[ i ] );
		if( i + 1 < ns.headers.Length )
			sb.print( ", " );
	}
	sb.line( " };" );

	sb.tabs( lvl + 1 );
	sb.print( "const std::array<const char*, {0}> names = ", ns.headers.Length );
	sb.line( lvl + 2 );
	sb.print( "{ " );
	sb.print( string.Join( ", ", ns.headers.Select( p => String.Format( @"R""({0})""", Path.GetFileName( p ).ToLowerInvariant() ) ) ) );
	sb.line( " };" );

	sb.tabs( lvl + 1 );

	// Include parent scope includes, if any
	NamespaceData parent = ns.parents().FirstOrDefault( n => n.anyInclude );
	if( null == parent )
		sb.line( "static const IncludesMap<{0}> result{{ names, tuples }};", ns.headers.Length );
	else
	{
		sb.line( "// Including headers from a parent scope." );
		sb.tabs( lvl + 1 );
		sb.line( "static const IncludesMap<{0}> result{{ ::{1}::includes(), names, tuples }};", ns.headers.Length, parent.fullName );
	}
	sb.tabs( lvl + 1 );
	sb.line( "return result.map;" );

	sb.tabs( lvl );
	sb.line( "};" );

	Console.WriteLine( "Generated {0} in {1}", pluralString( ns.headers.Length, "include" ), ns.fullName );
}

static int firstIndex( string[] lines, Func<string,bool> test, int start = 0 )
{
	for( int i = start; i < lines.Length; i++ )
		if( test( lines[ i ] ) )
			return i;
	return -1;
}

void writeTemplate( CppBuilder sb, int lvl, string sourcePath )
{
	// Cleanup unused "#ifndef AVS_SHADER" portion of the HLSL, to save a bit of space.
	string[] lines = File.ReadAllLines( sourcePath );
	int indAvxShaderIfdef = firstIndex( lines, s => s == "#ifndef AVS_SHADER" );

	if( indAvxShaderIfdef >= 0 )
	{
		int indEndif = firstIndex( lines, s => s.StartsWith( "#endif" ), indAvxShaderIfdef );
		if( indEndif < 0 ) throw new ArgumentException( "Unmatched `#ifndef AVS_SHADER` in " + sourcePath );

		List<string> newLines = new List<string>();
		newLines.AddRange( lines.Take( indAvxShaderIfdef ) );
		newLines.AddRange( lines.Skip( indEndif + 1 ) );
		lines = newLines.ToArray();
		// Console.WriteLine( string.Join( "\r\n", lines ) );
	}

	byte[] orig = Encoding.ASCII.GetBytes( string.Join( "\r\n", lines ) );
	byte[] compressed = compressBuffer( orig );

	sb.setTabs( lvl );
	sb.tl( "const ShaderTemplate* {0}::shaderTemplate()", Path.GetFileNameWithoutExtension( sourcePath ) );
	sb.tl( "{" );
	sb.incTabs();
	if( compressed.Length < ( orig.Length + lines.Length - 1 ) )
	{
		sb.tl( "const uint8_t src[] =" );
		printBytes( sb, compressed );
		sb.tl( "static const ShaderTemplate result{{ R\"({0})\", decompressString( src, {1}, {2} ) }};", Path.GetFileName( sourcePath ), compressed.Length, orig.Length );
	}
	else
	{
		sb.tl( @"const char src[] = R""fffuuu({0})fffuuu"";", string.Join( "\r\n", lines ) );
		sb.tl( "static const ShaderTemplate result{{ R\"({0})\", src }};", Path.GetFileName( sourcePath ) );
	}
	sb.tl( "return &result;" );
	sb.decTabs();
	sb.tl( "};" );

	Console.WriteLine( "Included a shader template from " + relativePath( sourceDir, sourcePath ) );
}

const string globalBegin = "<global>";
const string globalEnd = "</global>";
const string entryPoint = "void main()";
const string isBeatMacro = "IS_BEAT";

static void writeStateTemplate( CppBuilder sb, int lvl, string sourcePath )
{
	string content = File.ReadAllText( sourcePath, Encoding.ASCII );

	// Find global blocks
	HashSet<string> globals = new HashSet<string>();
	int iStart = 0;
	while( true )
	{
		iStart = content.IndexOf( globalBegin, iStart );
		if( iStart < 0 ) break;
		iStart += globalBegin.Length;

		int iEnd = content.IndexOf( globalEnd, iStart );
		if( iEnd < 0 )
			throw new ArgumentException( "<globals> tag wasn't closed in " + sourcePath );
		int iNewStart = iEnd + globalEnd.Length;
		for( iEnd--; content[ iEnd ] != '\n'; iEnd-- );

		string g = content.Substring( iStart, iEnd - iStart ).Trim();
		globals.Add( g );
	}

	// Find main
	iStart = content.IndexOf( entryPoint );
	if( iStart < 0 )
		throw new ArgumentException( "\"void main()\" wasn't found in" + sourcePath );
	iStart += entryPoint.Length;
	content = content.Substring( iStart ).Trim();

	// Compress and write the data

	sb.line( lvl );
	sb.print( "const StateShaderTemplate* {0}::shaderTemplate()", Path.GetFileNameWithoutExtension( sourcePath ) );
	sb.line( lvl );
	sb.line( "{" );

	string[] arr = globals.ToArray();
	List<byte[]> compressed = arr.Select( compressString ).ToList();
	for( int i = 0; i < arr.Length; i++ )
	{
		sb.tabs( lvl + 1 );
		sb.line( "const uint8_t globalData{0}[] = ", i );
		printBytes( sb, compressed[ i ] );
	}

	sb.tabs( lvl + 1 );
	sb.print( "static const std::vector<CStringA> globals{ " );
	for( int i = 0; i < arr.Length; i++ )
	{
		sb.print( "decompressString( globalData{0}, {1}, {2} )", i, compressed[ i ].Length, arr[ i ].Length );
		if( i + 1 != arr.Length )
			sb.print( ", " );
	}
	sb.line( " };" );

	byte[] hlslData = compressString( content );
	sb.tabs( lvl + 1 );
	sb.line( "const uint8_t hlslData[] = " );
	printBytes( sb, hlslData );

	bool hasBeat = content.Contains( isBeatMacro ) || arr.Any( s => s.Contains( isBeatMacro ) );
	sb.tabs( lvl + 1 );
	sb.line( "static const StateShaderTemplate result{{ R\"({0})\", decompressString( hlslData, {1}, {2} ), {3}, globals }};",
		Path.GetFileName( sourcePath ),
		hlslData.Length, content.Length, 
		hasBeat ? "true" : "false" );
	sb.tabs( lvl + 1 );
	sb.line( "return &result;" );

	sb.tabs( lvl );
	sb.line( "};" );
}

void generateNamespaces( CppBuilder sb, NamespaceData ns, int lvl )
{
	if( ns.anyInclude )
		writeIncludes( sb, ns, lvl );

	if( ns.sources.Length > 0 )
	{
		foreach( string s in ns.sources )
		{
			if( isStateTemplate( s ) )
				writeStateTemplate( sb, lvl, s );
			else
				writeTemplate( sb, lvl, s );
		}
	}
}
#>