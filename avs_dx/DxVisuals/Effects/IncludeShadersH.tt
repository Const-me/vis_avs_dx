<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".h" #>
<#@ assembly name="System.dll" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
#pragma once
// This file is automatically generated.
#include "../Hlsl/ShaderTemplate.h"
#include "../Hlsl/StateShaderTemplate.h"
#include "../Hlsl/Defines.h"
#include "../Expressions/variableTypes.h"

namespace Hlsl
{
<#= writeNamespaces( generateNamespace ) #>
	namespace StaticShaders
	{
<# foreach( string cso in staticShaders ) {
	   string name = Path.GetFileNameWithoutExtension( cso );
#>		std::vector<uint8_t> <#= name #>();
<# } #>
	}
}<#@ include file="IncludeShaders.t4"#><#+

static void generateNamespace( CppBuilder sb, NamespaceData ns, int lvl )
{
	if( ns.anyInclude )
	{
		sb.tabs( lvl );
		sb.line( "const CAtlMap<CStringA, CStringA>& includes();" );
	}

	if( ns.anyInclude && ns.anySource )
		sb.line();

	if( ns.anySource )
	{
		foreach( string s in ns.sources )
			generateShaderStruct( sb, s, lvl );
	}
}

static readonly Regex s_reConst = new Regex( @"^static const\s+(\S+)\s+(\S+)\s+=\s+(.+);$" );

static readonly Regex s_reVal = new Regex( @"^\s*(\S+)\s*\((.*)\)" );

interface iConstDecl
{
	string name{ get; }
	string member();
	void defines( CppBuilder sb );
}

class ConstDecl: iConstDecl
{
	readonly string tp, val;
	public string name{ get; private set; }
	public ConstDecl( string str )
	{
		var m = s_reConst.Match( str );
		tp = m.Groups[ 1 ].Value;
		name = m.Groups[ 2 ].Value;
		val = m.Groups[ 3 ].Value;
	}
	public string member() { return $"{tp} {name} = {val};"; }
	public void defines( CppBuilder sb )
	{
		sb.tl( @"def.set( ""{0}"", {1} );", name, name );
	}
}

class VectorDecl: iConstDecl
{
	public string name { get; private set; }
	readonly string tp, size, vals;
	public VectorDecl( string str )
	{
		var node = XDocument.Parse( str.Substring( str.IndexOf( "<macro-vector" ) ) ).Root;
		tp = node.Attribute( "type" ).Value;
		name = node.Attribute( "name" ).Value;
		size = node.Attribute( "size" ).Value;
		vals = node.Attribute( "values" ).Value;
	}
	public string member() { return $"std::vector<{tp}> {name};"; }
	public void defines( CppBuilder sb )
	{
		sb.tl( @"def.set( ""{0}"", (int){1}.size() );", size, name );
		sb.tl( @"def.set( ""{0}"", {1} );", vals, name );
	}
}

class CodeDecl: iConstDecl
{
	public string name { get; private set; }
	readonly string macro;
	public CodeDecl( string str )
	{
		var node = XDocument.Parse( str.Substring( str.IndexOf( "<macro-code" ) ) ).Root;
		name = node.Attribute( "name" ).Value;
		macro = node.Attribute( "macro" ).Value;
	}
	public string member() { return $"CStringA {name};"; }
	public void defines( CppBuilder sb )
	{
		sb.tl( @"def.set( ""{0}"", {1} );", macro, name );
	}
}

static iConstDecl[] parseConstants( string[] lines )
{
	List<iConstDecl> res = new List<iConstDecl>();
	res.AddRange( lines.Where( l => l.StartsWith( "static const" ) ).Select( s => new ConstDecl( s ) ) );
	res.AddRange( lines.Where( l => l.Contains( "<macro-vector" ) ).Select( s => new VectorDecl( s ) ) );
	res.AddRange( lines.Where( l => l.Contains( "<macro-code" ) ).Select( s => new CodeDecl( s ) ) );
	return res.ToArray();
}

static void generateShaderStruct( CppBuilder sb, string sourcePath, int lvl )
{
	string[] lines = File.ReadAllLines( sourcePath );
	iConstDecl[] decls = parseConstants( lines );

	sb.setTabs( lvl );
	sb.line();

	string name = Path.GetFileNameWithoutExtension( sourcePath );
	sb.tl( "struct {0}", name );
	sb.tl( "{" );
	sb.incTabs();
	sb.tl( "static const {0}* shaderTemplate();", isStateTemplate( sourcePath ) ? "StateShaderTemplate" : "ShaderTemplate", name );
	if( decls.Length > 0 )
	{
		sb.line();
		foreach( var d in decls )
			sb.tl( d.member() );

		sb.line();
		sb.tl( "bool operator==( const {0}& that ) const", name );
		sb.tl( "{" );
		sb.tl( "	return {0};", string.Join( " && ", decls.Select( d=> string.Format( "{0} == that.{0}", d.name ) ) ) );
		sb.tl( "}" );

		sb.line();

		sb.tl( "HRESULT defines( Hlsl::Defines& def ) const" );
		sb.tl( "{" );
		sb.incTabs();
		foreach( var d in decls )
			d.defines( sb );
		sb.tl( "return S_OK;" );
		sb.decTabs();
		sb.tl( "}" );
	}

	sb.decTabs();
	sb.tl( "};" );
}
#>