<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cpp" #>
<#@ assembly name="System.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.ComponentModel" #>
// This file is automatically generated.
#include "stdafx.h"
#include "shadersCode.h"
#include <compressapi.h>
#include <tuple>

namespace
{
	#pragma comment( lib, "Cabinet.lib" )
	constexpr DWORD compressionAlgorithm = COMPRESS_ALGORITHM_MSZIP;

	class Decompressor
	{
		DECOMPRESSOR_HANDLE handle = nullptr;

	public:
		Decompressor()
		{
			if( CreateDecompressor( compressionAlgorithm, nullptr, &handle ) )
				return;
			logError( getLastHr(), "CreateDecompressor failed" );
			__debugbreak();
		}

		void decompress( const uint8_t* src, int compressedLength, void* dest, int origLength ) const
		{
			if( Decompress( handle, src, (size_t)compressedLength, dest, (size_t)origLength, nullptr ) )
				return;
			logError( getLastHr(), "Decompress failed" );
			__debugbreak();
		}
	};

	static const Decompressor s_decompressor;

	std::vector<uint8_t> decompressBytes( const uint8_t* src, int compressedLength, int origLength )
	{
		std::vector<uint8_t> result;
		result.resize( (size_t)origLength );
		s_decompressor.decompress( src, compressedLength, result.data(), origLength );
		return std::move( result );
	}

	CStringA decompressString( const uint8_t* src, int compressedLength, int origLength )
	{
		CStringA result;
		s_decompressor.decompress( src, compressedLength, result.GetBufferSetLength( origLength + 1 ), origLength );
		result.ReleaseBuffer( origLength );
		return std::move( result );
	}

	template<size_t size>
	class IncludesMap
	{
		void decompress( std::array<const char*, size> names, std::array<std::tuple<const uint8_t*, int, int>, size> compressedValues )
		{
			for( size_t i = 0; i < size; i++ )
				map[ names[ i ] ] = std::apply( decompressString, compressedValues[ i ] );
		}
	public:
		CAtlMap<CStringA, CStringA> map;

		IncludesMap( std::array<const char*, size> names, std::array<std::tuple<const uint8_t*, int, int>, size> compressedValues )
		{
			decompress( names, compressedValues );
			map.Rehash();
		}
	};
}

namespace Hlsl
{<#= writeNamespaces( generateNamespaces ) #>
	namespace StaticShaders
	{
		<#= makeStaticShaders() #>
	}
}<#@ include file="IncludeShaders.t4"#><#+
const int valsPerLine = 32;

static void printBytes( CppBuilder sb, byte[] data )
{
	sb.line( "\t\t\t{" );
	for( int i = 0; true; )
	{
		int count = Math.Min( valsPerLine, data.Length - i );
		sb.print( "\t\t\t\t" );
		var values = data.Skip( i ).Take( count );
		var strings = values.Select( b => string.Format( "0x{0:X2}", b ) );
		sb.print( string.Join( ", ", strings ) );
		i += count;
		if( i < data.Length ) 
		{
			sb.line( "," );
			continue;
		}
		break;
	}
	sb.line();
	sb.line( "\t\t\t};" );
}

void makeShader( CppBuilder sb, string path )
{
	byte[] orig = File.ReadAllBytes( path );
	byte[] compressed = compressBuffer( orig );
	sb.line( "std::vector<uint8_t> {0}()", Path.GetFileNameWithoutExtension( path ) );
	sb.line( "		{" );
	sb.line( "			const uint8_t src[] =", compressed.Length );
	printBytes( sb, compressed );
	sb.line( "			std::vector<uint8_t> result = decompressBytes( src, {0}, {1} );", compressed.Length, orig.Length );
	sb.line( "			return std::move( result );" );
	sb.line( "		};" );
	Console.WriteLine( "Included a static shader from {0}", path );
}

string makeStaticShaders()
{
	CppBuilder sb = new CppBuilder();
	foreach( var path in staticShaders )
	{
		makeShader( sb, path );
		sb.line();
	}
	return sb.ToString().Trim();
}

static void generateNamespaces( CppBuilder sb, NamespaceData ns, int lvl )
{
	// TODO [low]: when needed, implement compile-time merging of these includes with ones in the parent namespace
	if( ns.headers.Length > 0 )
	{
		sb.line( lvl );
		sb.print( "const CAtlMap<CStringA, CStringA>& includes()" );
		sb.line( lvl );
		sb.line( "{" );
		int[] origSize = new int[ ns.headers.Length ];
		int[] cmpSize = new int[ ns.headers.Length ];
		for( int i = 0; i < ns.headers.Length; i++ )
		{
			string hlsl = ns.headers[ i ];
			byte[] orig = File.ReadAllBytes( hlsl );
			byte[] compressed = compressBuffer( orig );

			sb.tabs( lvl + 1 );
			sb.line( "const uint8_t {0}[] =", Path.GetFileNameWithoutExtension( hlsl ) );
			printBytes( sb, compressed );
			origSize[ i ] = orig.Length;
			cmpSize[ i ] = compressed.Length;
		}

		sb.line( lvl + 1 );
		sb.print( "const std::array<std::tuple<const uint8_t*, int, int>, {0}> tuples = ", ns.headers.Length );
		sb.line( lvl + 2 );
		sb.print( "{ " );
		for( int i = 0; i < ns.headers.Length; i++ )
		{
			sb.print( "std::make_tuple( &{0}[0], {1}, {2} )", Path.GetFileNameWithoutExtension( ns.headers[ i ] ), cmpSize[ i ], origSize[ i ] );
			if( i + 1 < ns.headers.Length )
				sb.print( ", " );
		}
		sb.line( " };" );

		sb.tabs( lvl + 1 );
		sb.print( "const std::array<const char*, {0}> names = ", ns.headers.Length );
		sb.line( lvl + 2 );
		sb.print( "{ " );
		sb.print( string.Join( ", ", ns.headers.Select( p => String.Format( @"R""({0})""", Path.GetFileName( p ).ToLowerInvariant() ) ) ) );
		sb.line( " };" );

		sb.tabs( lvl + 1 );
		sb.line( "static const IncludesMap<{0}> result{{ names, tuples }};", ns.headers.Length );
		sb.tabs( lvl + 1 );
		sb.line( "return result.map;" );

		sb.tabs( lvl );
		sb.line( "};" );
	}

	if( ns.sources.Length > 0 )
	{
		foreach( string s in ns.sources )
		{
			byte[] orig = File.ReadAllBytes( s );
			byte[] compressed = compressBuffer( orig );

			sb.line( lvl );
			string name = Path.GetFileNameWithoutExtension( s );
			string content = File.ReadAllText( s, Encoding.ASCII );
			sb.print( "const ShaderTemplate& {0}()", name );
			sb.line( lvl );
			sb.print( "{" );
			sb.line( lvl + 1 );
			sb.line( "const uint8_t src[] =" );
			printBytes( sb, compressed );

			sb.tabs( lvl + 1 );
			sb.line( "static const ShaderTemplate result{{ R\"({0})\", decompressString( src, {1}, {2} ) }};", Path.GetFileName( s ), compressed.Length, orig.Length );
			sb.tabs( lvl + 1 );
			sb.line( "return result;" );

			sb.tabs( lvl );
			sb.print( "};" );
		}
	}
}

static IntPtr hCompressor = IntPtr.Zero;

enum eCompressionAlgorithm: uint
{
	MSZIP = 2,
	XPRESS = 3,
	XPRESS_HUFF = 4,
	LZMS = 5,
}

const eCompressionAlgorithm algo = eCompressionAlgorithm.MSZIP;

[DllImport( "Cabinet.dll", SetLastError = true )]
static extern bool CreateCompressor( eCompressionAlgorithm Algorithm, IntPtr AllocationRoutines, out IntPtr CompressorHandle );

[DllImport( "Cabinet.dll", SetLastError = true )]
static extern bool Compress(IntPtr CompressorHandle, [In] byte[] UncompressedData, IntPtr UncompressedDataSize, [Out] byte[] CompressedBuffer, IntPtr CompressedBufferSize, out IntPtr CompressedDataSize);

static byte[] compressBuffer( byte[] src )
{
	if( hCompressor == IntPtr.Zero )
		if( !CreateCompressor( algo, IntPtr.Zero, out hCompressor ) )
			throw new Win32Exception();
	byte[] dest = new byte[ src.Length * 2 ];
	IntPtr srcSize = new IntPtr( src.Length );
	IntPtr destSize = new IntPtr( src.Length * 2 );
	if( !Compress( hCompressor, src, srcSize, dest, destSize, out destSize ) )
		throw new Win32Exception();
	Array.Resize( ref dest, (int)destSize );
	return dest;
}
#>