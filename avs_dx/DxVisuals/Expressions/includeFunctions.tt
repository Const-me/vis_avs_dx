<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cpp" #>
<#@ assembly name="System.dll" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="System.ComponentModel" #>
// This file is automatically generated.
#include "stdafx.h"
#include "includeFunctions.h"
#include "../Utils/decompressor.h"

namespace Expressions
{
	struct ShaderFunctions
	{
		std::vector<uint8_t> buffer;
		CAtlMap<CStringA, ShaderFunc> map;

		ShaderFunctions();
	};

	static const ShaderFunctions s_functions;

	const ShaderFunc* lookupShaderFunc( const CStringA& name )
	{
		auto p = s_functions.map.Lookup( name );
		if( nullptr == p )
			return nullptr;
		return &p->m_value;
	}

	ShaderFunctions::ShaderFunctions()
	{
		const uint8_t compressedData[] =
<#
	byte[] buffer;
	int origLength;
	CompressedFunction[] functions;
	compressFunctions( out buffer, out origLength, out functions );
	CppBuilder sb = new CppBuilder();
	printBytes( sb, buffer );
#><#= sb.ToString() #>		buffer = decompressBytes( compressedData, <#= buffer.Length #>, <#= origLength #> );
		const char* const ptr = (const char*)buffer.data();
<#
	foreach( var func in functions )
	{	
#>		map[ "<#= func.name #>" ] = ShaderFunc{ eVarType::<#= func.retType #>, ptr + <#= func.offset #> };
<#	} #>
		map.Rehash();
	}
}<#@ include file="includeFunctions.t4"#>