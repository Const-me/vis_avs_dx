<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".h" #>
<#@ assembly name="System.dll" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
#pragma once
// This file is automatically generated.
#include "../Utils/ByteRange.hpp"
#include "../Hlsl/ShaderTemplate.h"
#include "../Hlsl/StateShaderTemplate.h"
#include "../Hlsl/Defines.h"
#include "../Hlsl/ShaderBaseStruct.h"
#include "../Render/Binder.h"
#include "../Expressions/variableTypes.h"

namespace Hlsl
{
<#= writeNamespaces( generateNamespace ) #>
	namespace StaticShaders
	{
<# foreach( string cso in staticShaders ) {
	   string name = Path.GetFileNameWithoutExtension( cso );
#>		ByteRange <#= name #>();
<# } #>
	}
}<#@ include file="IncludeShaders.t4"#><#+

static void generateNamespace( CppBuilder sb, NamespaceData ns, int lvl )
{
	if( ns.anyInclude )
	{
		sb.tabs( lvl );
		sb.line( "const CAtlMap<CStringA, CStringA>& includes();" );
	}

	if( ns.anyInclude && ns.anySource )
		sb.line();

	if( ns.anySource )
	{
		foreach( string s in ns.sources )
			generateShaderStruct( sb, s, lvl );
	}
}

static readonly Regex s_reConst = new Regex( @"^static const\s+(\S+)\s+(\S+)\s+=\s+(.+);$" );

static readonly Regex s_reVal = new Regex( @"^\s*(\S+)\s*\((.*)\)" );

interface iConstDecl
{
	string name{ get; }
	string member();
	void defines( CppBuilder sb );
}

class ConstDecl: iConstDecl
{
	readonly string tp, val;
	public string name{ get; private set; }
	public ConstDecl( string str )
	{
		var m = s_reConst.Match( str );
		if( !m.Success )
			throw new ArgumentException( "Unable to parse the constant declaration:\r\n" + str );
		tp = m.Groups[ 1 ].Value;
		name = m.Groups[ 2 ].Value;
		val = m.Groups[ 3 ].Value;
	}
	public string member() { return $"{tp} {name} = {val};"; }
	public void defines( CppBuilder sb )
	{
		sb.tl( @"def.set( ""{0}"", {1} );", name, name );
	}
}

class VectorDecl: iConstDecl
{
	public string name { get; private set; }
	readonly string tp, size, vals;
	public VectorDecl( string str )
	{
		var node = XDocument.Parse( str.Substring( str.IndexOf( "<macro-vector" ) ) ).Root;
		tp = node.Attribute( "type" ).Value;
		name = node.Attribute( "name" ).Value;
		size = node.Attribute( "size" ).Value;
		vals = node.Attribute( "values" ).Value;
	}
	public string member() { return $"std::vector<{tp}> {name};"; }
	public void defines( CppBuilder sb )
	{
		sb.tl( @"def.set( ""{0}"", (int){1}.size() );", size, name );
		sb.tl( @"def.set( ""{0}"", {1} );", vals, name );
	}
}

/* class CodeDecl: iConstDecl
{
	public string name { get; private set; }
	readonly string macro;
	public CodeDecl( string str )
	{
		var node = XDocument.Parse( str.Substring( str.IndexOf( "<macro-code" ) ) ).Root;
		name = node.Attribute( "name" ).Value;
		macro = node.Attribute( "macro" ).Value;
	}
	public string member() { return $"CStringA {name};"; }
	public void defines( CppBuilder sb )
	{
		sb.tl( @"def.set( ""{0}"", {1} );", macro, name );
	}
} */

class BindingDecl: iConstDecl
{
	public string name { get; private set; }
	readonly string macro;
	public readonly char typeChar = 't';
	public BindingDecl( string str )
	{
		var node = XDocument.Parse( str.Substring( str.IndexOf( "<macro-resource" ) ) ).Root;
		name = node.Attribute( "name" ).Value;
		macro = node.Attribute( "macro" ).Value;
		var typeAttr = node.Attribute( "type" );
		if( null != typeAttr )
			typeChar = parseType( typeAttr.Value );
	}
	public string member() { return $"UINT {name} = UINT_MAX;"; }
	public void defines( CppBuilder sb )
	{
		sb.tl( @"def.setBinding( ""{0}"", '{1}', {2} );", macro, typeChar, name );
	}
	static char parseType( string t )
	{
		switch( t.ToLowerInvariant() )
		{
			case "srv": return 't';
			case "uav": return 'u';
			case "cbuffer": return 'b';
			case "sampler": return 's';
		}
		throw new ArgumentException( "Unsupported type attribute {0} in <macro-resource> element", t );
	}
}

static iConstDecl[] parseConstants( string[] lines )
{
	List<iConstDecl> res = new List<iConstDecl>();
	res.AddRange( lines.Where( l => l.Contains( "<macro-resource" ) ).Select( s => new BindingDecl( s ) ) );
	res.AddRange( lines.Where( l => l.StartsWith( "static const" ) ).Select( s => new ConstDecl( s ) ) );
	res.AddRange( lines.Where( l => l.Contains( "<macro-vector" ) ).Select( s => new VectorDecl( s ) ) );
	// res.AddRange( lines.Where( l => l.Contains( "<macro-code" ) ).Select( s => new CodeDecl( s ) ) );
	return res.ToArray();
}

static string stageString( string sourcePath )
{
	string name = Path.GetFileNameWithoutExtension( sourcePath ).ToLowerInvariant();
	if( name.EndsWith( "cs" ) ) return "Compute";
	if( name.EndsWith( "vs" ) ) return "Vertex";
	if( name.EndsWith( "gs" ) ) return "Geometry";
	if( name.EndsWith( "ps" ) ) return "Pixel";
	return null;
}

static void generateShaderStruct( CppBuilder sb, string sourcePath, int lvl )
{
	string[] lines = File.ReadAllLines( sourcePath );
	iConstDecl[] decls = parseConstants( lines );

	sb.setTabs( lvl );
	sb.line();

	string name = Path.GetFileNameWithoutExtension( sourcePath );
	string stage = stageString( sourcePath );

	string baseClass = "";
	if( null !=stage )
		baseClass = $": public ShaderBaseStruct<eStage::{stage}>";
	sb.tl( "struct {0}{1}", name, baseClass );
	sb.tl( "{" );
	sb.incTabs();
	sb.tl( "static const {0}* shaderTemplate();", isStateTemplate( sourcePath ) ? "StateShaderTemplate" : "ShaderTemplate", name );
	if( decls.Length > 0 )
	{
		sb.line();
		foreach( var d in decls )
			sb.tl( d.member() );

		iConstDecl[] shaderConstantDecls = decls.Where( d => !( d is BindingDecl ) ).ToArray();
		if( shaderConstantDecls.Length > 0 )
		{
			// Write `operator=` that copies data members, but excludes resource binding slots.
			sb.line();
			sb.tl( "void operator=( const {0}& that )", name );
			sb.tl( "{" );
			sb.incTabs();
			foreach( var d in shaderConstantDecls )
				sb.tl( "{0} = that.{0};", d.name );
			sb.decTabs();
			sb.tl( "}" );
			sb.line();

			// Write `operator==` that compares data members, but excludes resource binding slots.
			sb.tl( "bool operator==( const {0}& that ) const", name );
			sb.tl( "{" );
			sb.tl( "	return {0};", string.Join( " && ", shaderConstantDecls.Select( d => string.Format( "{0} == that.{0}", d.name ) ) ) );
			sb.tl( "}" );
		}

		BindingDecl[] bindings = decls.OfType<BindingDecl>().ToArray();
		if( bindings.Length > 0 && null != stage )
		{
			sb.line();
			sb.tl( "bool updateBindings( Binder& binder )" );
			sb.tl( "{" );
			sb.incTabs();
			sb.tl( "bool changed = false;" );
			foreach( var b in bindings )
				sb.tl( "if( binder.reserveInputSlot( {0}, eStage::{1}, '{2}' ) ) changed = true;", b.name, stage, b.typeChar );
			sb.tl( "return changed;" );
			sb.decTabs();
			sb.tl( "}" );
		}

		sb.line();
		sb.tl( "HRESULT defines( Hlsl::Defines& def ) const" );
		sb.tl( "{" );
		sb.incTabs();
		foreach( var d in decls )
			d.defines( sb );
		sb.tl( "return S_OK;" );
		sb.decTabs();
		sb.tl( "}" );
	}

	sb.decTabs();
	sb.tl( "};" );
}
#>