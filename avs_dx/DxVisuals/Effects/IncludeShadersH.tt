<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".h" #>
<#@ assembly name="System.dll" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
#pragma once
// This file is automatically generated.
#include "../Hlsl/ShaderTemplate.h"
#include "../Hlsl/StateShaderTemplate.h"
#include "../Hlsl/Defines.h"

namespace Hlsl
{
<#= writeNamespaces( generateNamespace ) #>
	namespace StaticShaders
	{
<# foreach( string cso in staticShaders ) {
	   string name = Path.GetFileNameWithoutExtension( cso );
#>		std::vector<uint8_t> <#= name #>();
<# } #>
	}
}<#@ include file="IncludeShaders.t4"#><#+

static void generateNamespace( CppBuilder sb, NamespaceData ns, int lvl )
{
	if( ns.anyInclude )
	{
		sb.tabs( lvl );
		sb.line( "const CAtlMap<CStringA, CStringA>& includes();" );
	}

	if( ns.anyInclude && ns.anySource )
		sb.line();

	if( ns.anySource )
	{
		foreach( string s in ns.sources )
		{
			sb.tabs( lvl );
			string name = Path.GetFileNameWithoutExtension( s );
			sb.line( "const {0}& {1}();", templateResultType( s ), name );

			if( isStateTemplate( s ) )
				generateStateData( sb, s, lvl );
		}
	}
}

static readonly Regex s_reConst = new Regex( @"^static const\s+(\S+)\s+(\S+)\s+=\s+(\S+);$" );

static string convertType( string t )
{
	switch( t )
	{
		case "uint": return "uint32_t";
		case "float2": return "Vector2";
		case "float3": return "Vector3";
		case "float4": return "Vector4";
	}
	return t;
}

interface iConstDecl
{
	string name{ get; }
	string member();
	void defines( CppBuilder sb );
}

class ConstDecl: iConstDecl
{
	public readonly string tp, val;
	public string name{ get; private set; }
	public ConstDecl( string str )
	{
		var m = s_reConst.Match( str );
		tp = convertType( m.Groups[ 1 ].Value );
		name = m.Groups[ 2 ].Value;
		val = m.Groups[ 3 ].Value;
	}
	public string member() { return $"{tp} {name} = {val};"; }
	public void defines( CppBuilder sb )
	{
		sb.tl( @"def.set( ""{0}"", {1} );", name, name );
	}
}

class VectorDecl: iConstDecl
{
	public readonly string tp, size, vals;
	public string name{ get; private set; }
	public VectorDecl( string str )
	{
		var node = XDocument.Parse( str.Substring( str.IndexOf( "<macro-vector" ) ) ).Root;
		tp = convertType( node.Attribute( "type" ).Value );
		name = node.Attribute( "name" ).Value;
		size = node.Attribute( "size" ).Value;
		vals = node.Attribute( "values" ).Value;
	}
	public string member() { return $"std::vector<{tp}> {name};"; }
	public void defines( CppBuilder sb )
	{
		sb.tl( @"def.set( ""{0}"", (int){1}.size() );", size, name );
		sb.tl( @"def.set( ""{0}"", {1} );", vals, name );
	}
}

static void generateStateData( CppBuilder sb, string sourcePath, int lvl )
{
	string[] lines = File.ReadAllLines( sourcePath );
	var enmConsts = lines.Where( l => l.StartsWith( "static const" ) ).Select( s => new ConstDecl( s ) );
	var enmVecs = lines.Where( l => l.Contains( "<macro-vector" ) ).Select( s => new VectorDecl( s ) );
	iConstDecl[] decls = enmConsts.Cast<iConstDecl>().Concat( enmVecs.Cast<iConstDecl>() ).ToArray();
	if( decls.Length <= 0 )
		return;

	sb.setTabs( lvl );
	sb.line();

	string name = Path.GetFileNameWithoutExtension( sourcePath );
	sb.tl( "struct {0}Struct", name );
	sb.tl( "{" );
	sb.incTabs();
	sb.tl( "static inline const StateShaderTemplate* shaderTemplate() {{ return &{0}(); }}", name );

	sb.line();
	foreach( var d in decls )
		sb.tl( d.member() );

	sb.line();
	sb.tl( "bool operator==( const {0}Struct& that ) const", name );
	sb.tl( "{" );
	sb.tl( "	return {0};", string.Join( " && ", decls.Select( d=> string.Format( "{0} == that.{0}", d.name ) ) ) );
	sb.tl( "}" );

	sb.line();

	sb.tl( "HRESULT defines( Hlsl::Defines& def ) const" );
	sb.tl( "{" );
	sb.incTabs();
	foreach( var d in decls )
		d.defines( sb );
	sb.tl( "return S_OK;" );
	sb.decTabs();
	sb.tl( "}" );

	sb.decTabs();
	sb.tl( "};" );
}
#>